%!TEX root = Main.tex
\section{Implementation}
The following chapter seeks to explain the implementation of the mini project.

\subsection{Overall Design}
The full system is comprised of one or two PCs and two TelosB motes configured as a receiver and a sender. The system can be describes as seen in figure \ref{FullSystem}. 
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{FullSystem}
	\caption{Full System Diagram.}
	\label{FullSystem}
\end{figure}
The PC software has three responsibilities. It takes an image and converts it to a binary file. This file is then wrapped into an array and prepared such that it can be transmitted to the TelosB mote. The transmission is handled by the Serial Communication block and can be seen in the Serial Communication subsection.

The TelosB motes are either configured as sender or receiver.  The sender has the responsibility of getting an image from the PC and transmitting it over the radio to the receiver mote. The receiver has the responsibility to receive the image from radio and transmitting it to the PC.

The Serial Communication block of the TelosB mote interacts with the PC's Serial Communication block as can be read in the Serial Communication subsection. The Radio Communication block interacts with other TelosB motes as can be read in the Radio Communication subsection. Lastly the Compression block has entails the compression and decompression of the image data. This is explained in the Compression block subsection.

\subsection{Serial Communication}
The serial communication is responsible for the transfer of the image to and from the TelosB. A header file is available to both the PC software and the TelosB program. It contains a series of defines that are used for the communication messages. The defines can be found in table \ref{definetable}.
\begin{table}[H]
    \begin{tabular}{|l|l|l|}
    \hline
    Name                  & Val & Description                                               \\ \hline
    TRANSFER\_TO\_TELOS   & 1     & Used to tell the TelosB to prepare to receive the image. \\ \hline
    TRANSFER\_OK          & 2     & Used to tell the PC that the transfer was ok.             \\ \hline
    TRANSFER\_FAIL        & 3     & Used to tell the PC that the transfer failed.             \\ \hline
    TRANSFER\_READY       & 4     & Used to tell the PC that the transfer can be initiated.   \\ \hline
    TRANSFER\_FROM\_TELOS & 5     & Used to tell the TelosB to transfer the image to the PC.  \\ \hline
    TRANSFER\_DONE        & 6     & Used to tell the PC that the image transfer is done.      \\ \hline
    \end{tabular}
    \caption{Defines for serial communication.}
    \label{definetable}
\end{table}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{PCtoTelosb}
	\caption{Transfer to TelosB sequence diagram.}
	\label{transfertotelos}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{PCfromTelosb}
	\caption{Transfer from TelosB sequence diagram.}
	\label{transferfromtelos}
\end{figure}

\subsection{Radio Block}

\subsection{Compression block}
The compression blocks have a common interface: 

\begin{itemize}
    \item \texttt{uint16\_t Compress(uint8\_t* in, uint8\_t* out)}
    \item \texttt{void Decompress(uint8\_t *in, uint8\_t *out)}
\end{itemize}

This interface allows the different implementation to be accessed with the same code -- only specifying the desired block.

The \texttt{Compress(...)} method will take 1024 bytes in its first parameter, and return the compressed data in its second parameter, and return the size of the compression as return output.

The \texttt{Decompress(...)} method will, too, take the input as the first parameter and output as second parameter. 
The \texttt{Decompress(...)} method already knows how big the input is, and the output will always 1024 bytes.

The One Bit Compression's \texttt{Compress(...)} method will split the input data up in chunks of 8 bytes at a time, and for each byte AND \texttt{0xFE} onto it (resulting in the last bit being 0, and leave the rest untouched), and OR one bit from the last byte unto its own last bit.
Then the modified bytes will be added to the output parameter.
This will be done for all 128 chunks of bytes (8 bytes pr. chunk).
Lastly it will return the size of the output parameter.

The One Bit Compression's \texttt{Decompress(...)} is the inverse operation of the \texttt{Compress(...)} method.
For each chunk of seven bytes it will, for each byte, AND \texttt{0xFE} and store them in the output parameter. 
Then it will look at the last bit for the seven (unmodified) input bytes and shift each of them into a new byte, and store it after the seven modified bytes in the output parameter.
